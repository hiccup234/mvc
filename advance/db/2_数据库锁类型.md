
# MySQL数据库锁分类：
 
    非事务性存储引擎：MyISAM、MEMORY、CSV  		采用表级锁定
    事务性存储引擎：InnoDB 						采用行级锁定
    （MyISAM与InnoDB最大的区别就是：MyISAM不支持事务）
    
    MyISAM引擎不支持事务处理等高级处理，而InnoDB引擎支持。
    
    MyISAM引擎的表强调的是性能，其执行数度比InnoDB引擎更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。
    
    InnoDB不支持FULLTEXT类型的索引。
    
    InnoDB中不保存表的具体行数，所以执行select count(*) from table时，InnoDB要全表扫描来计算有多少行，
    但是MyISAM只要简单的读出保存好的行数即可。注意：当count(*)语句包含 where条件时，两种表的操作是一样的。
    
    对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
    
    DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    
    LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，
    导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
 
## 表级锁定
  * 加锁开销小，速度快
  * 不会出现死锁
  * 锁的粒度大，发生锁冲突的概率最高
  * 并发度最低
 
    直接由MySQL服务器实现，底层存储引擎不用关心，分为： 表共享读锁（Table Read Lock） 和 表独占写锁（Table Write Lock）
 
## 页级锁定
  MySQL特有的锁定级别，BerkeleyDB采用了页级锁定
 
## 行级锁定
  * 加锁开销大，速度慢
  * 会出现死锁的情况
  * 锁定粒度最小，发生锁冲突的概率最低
  * 并发度最高
 
    由存储引擎实现，分为：共享锁 和 排他锁，InnoDB同时也使用了意向锁（表级锁定），分为意向共享锁和意向排它锁。
    意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。
 
  事务可以通过以下语句显示给记录集加共享锁或排他锁：
  共享锁（S）：SELECT  FROM table_name WHERE ... LOCK IN SHARE MODE
  排他锁（X）：SELECT  FROM table_name WHERE ... FOR UPDATE
 
## 注意：InnoDB的行锁是通过给索引上的索引项加锁来实现的，所以只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。
 
## 间隙锁（GAP）
  当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；
  对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”InnoDB也会对这个“间隙”加锁，可以防止幻读，以满足相关隔离级别的要求。
 
  Read committed 不会加GAP锁
 
  Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。
 
  通过索引实现锁定
  （1）当Query无法利用索引的时候，InnoDB会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低。
  （2）当Query使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所对应的数据可能有部分并不属于该Query的结果集，
       但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；
 
 
## 悲观锁与乐观锁
```
  悲观锁与乐观锁并不是数据库中独有的概念，Java语言中synchronized是悲观锁，自旋的CAS是乐观锁操作。
  MySQL中悲观锁一般是：select ... for update的语句，会对选择的数据加锁，防止其他事务修改数据。
  乐观锁则同JUC中AtomicFieldUpdater类似，也是利用CAS机制，并不会对数据加锁，而是对比每行数据的系统版本号来判断。
```