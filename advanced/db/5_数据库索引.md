
# 数据库索引



### 一般来说，应该在这些列创建索引：

   * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；

   * 在经常需要搜索的列上，可以加快搜索的速度；
   
   * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
   
   * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
   
   * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
   
   * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
   

### 一般来说，不应该在这些列创建索引：

   * 对于那些在查询中很少使用或者参考的列不应该创建索引。
   
   * 对于那些只有很少数据值的列也不应该增加索引。
   
   * 对于那些定义为text,image和bit数据类型的列不应该增加索引
   
   
### 主键索引 
    数据库表经常有一列或列组合，其值唯一标识表中的每一行，该列称为表的主键。 
    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键中的每个值都唯一。

### 聚集索引
    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
    如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度
    
### 局部性原理与磁盘预读
    由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一。
    因此为了提高效率，要尽量减少磁盘I/O，为了达到这个目的，磁盘I/O往往不是严格按需读取，而是每次都会预读，
    即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
    
    这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。
    
    程序运行期间所需要的数据通常比较集中，由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），
    因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数，页是计算机管理存储器的逻辑块，
    硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4KB），
    主存和磁盘以页为单位交换数据，当程序要读取的数据不在主存中时，会触发一个缺页中断，此时系统会向磁盘发出读盘信号，
    磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中然后返回，程序继续运行。
    
### B-/+Tree索引的性能分析  
    
    一般使用磁盘I/O次数来评价索引结构的优劣。
    
    根据B-Tree的定义，可知检索一次最多需要访问h（树高度）个节点，数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，
    这样每个节点只需要一次I/O就可以完全载入，为了达到这个目的，在实际实现B-Tree时还需要使用如下技巧：
        1、每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
        2、B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。
           一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
        3、而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，
           所以红黑树的I/O渐进复杂度也为O(h)，但效率明显比B-Tree差很多。
    
    
    
    
    
    
    
    
    