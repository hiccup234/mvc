
# 数据库事务特性ACID（MySQL中，事务支持是在引擎层实现的）

## 原子性：atomicity
    一个事务必须被视为不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚

## 一致性：consistency
    数据库总是从一个一致性的状态转换到另外一个一致性的状态（事务开始之前和事务结束以后，数据库的完整性约束没有被破坏）

## 隔离性：isolation
    不同的事务需要遵循一定的隔离级别（这里的隔离应该是用户读的隔离，如果是更新操作，则需要“当前读”，即看到最新数据）

## 持久性：durability
    一旦事务提交，其所作的修改就应该永久保存在数据库中（持久化到磁盘），即使系统崩溃，修改的数据也不会丢失
```
 原子性和一致性的区别？（由WAL技术提供支持）
 原子性：侧重于事务执行的完整性（只要有一个操作失败，那么整个事务就要回滚）
 一致性：侧重于事务的执行结果是按预期生效的（对比多核CPU缓存一致性协议和能量守恒定律）

 举个栗子：
 张三给李四转账100元。数据库假设需要张三扣100，李四加100，记录一条流水。
 如果流水没记录成功，那么整个事务回滚，张三没扣钱，李四也没多钱，这就是原子性的体现。
 而张三必须扣100，李四必须加100，这个就是一致性了，如果因为某些逻辑原因，导致张三扣了100，流水记录100转账，
 而李四只加了60，然后这3条操作都成功了，那原子性就符合了，但是不符合一致性。
```

# 传统数据库管理系统的事务隔离级别:

## 读未提交：Read uncommitted
    一个事务能够看到其他事务尚未提交的修改，允许脏读出现。

## 读已提交：Read committed
    事务能够看到的数据都是其他事务已经提交的修改，但是无法保证再次读取时能获取到同样的数据，即允许其他事务并发修改数据，
    不会出现脏读，但是允许不可重复读和幻象读（Phantom Read）。

## 可重复读：Repeatable reads
    保证同一个事务多次读取的数据都是一致的，是MySQL InnoDB存储引擎的默认隔离级别，MySQL在可重复读级别不会出现幻象读
    （通过多版本并发控制MVCC：Multiversion Concurrency Control），但是SQL标准的隔离级别还是会出现幻读问题
    
    幻读：幻读仅争对新插入的行，如果是同事务中先后读到其他事务修改的数据，则不是幻读而是不可重复读，幻读一定是争对新插入的行。

## 串行化：Serializable
    并发的事务之间时串行化的，通常意味着读取需要获取共享锁，更新需要获取排他锁（读写锁），MySQL实现中，如果SQL语句中含有Where，
    则还会获取区间锁（GAP锁，可重复读级别中默认也会使用）

    注意：MySQL默认的事务隔离级别是“可重复读”，而其他大多数数据库默认级别是“读已提交”（如Oracle、SQLServer等），
         但是互联网项目一般都会修改默认级别为 “读已提交” + binlog的row模式。
```
Q: 为什么MYSQL的默认级别是“可重复读”呢？
A: 由于历史原因，MySQL主从复制都是基于binlog的，而binlog有三种模式：
     1、statement:记录的是修改SQL语句
     2、row：记录的是每行实际数据的变更
     3、mixed：statement和row模式的混合
Mysql在5.1.5版本以前，binlog只支持statement格式！而这种格式在读已提交(Read committed)级别下主从复制是有bug的。
（如果事务1先执行条件删除，还未提交，此时事务2插入某条符合事务1条件的数据并提交，然后事务1再提交，
 那么主从复制的时候binlog中按commit先后记录的是先插后删，而主库则是先删后插，会导致主从不一致的问题，
 因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别），5.1版本后，默认binlog的格式改为了row，基于数据行复制，便不会再出现这个bug了。

互联网项目中一般都不用“读未提交”和“串行化”，所以一般都是在“读已提交”RC和“可重复读”RR中做选择，为什么选择RC呢?
     1、在RR级别下存在间隙锁（GAP），导致出现死锁的几率比RC大很多
     2、在RR隔离级别下，条件列未命中索引会锁表，而在RC隔离级别下，只锁行
     3、在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性
```

```
除了update语句外，select语句如果加锁，也是“当前读”，会看到最新事务提交的数据
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

```
// 查看事务隔离级别
select @@tx_isolation;
//1）read uncommitted : 读取尚未提交的数据
//2）read committed：读取已经提交的数据 ：可以解决脏读 ---- oracle默认的
//3）repeatable read：重读读取：可以解决脏读 和 不可重复读 --- mysql默认的
//4）serializable：串行化：可以解决 脏读 不可重复读 和 幻读 --- 相当于锁表
// 重新设置当前会话事务隔离级别
set session transaction isolation level read committed
```

### 预写式日志（Write-ahead logging，缩写WAL）
    关系数据库系统中用于提供原子性和持久性的一系列技术，
    在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中，log文件中通常包括redo和undo信息。
    
#### binlog
    MySQL服务层实现的，主要用来归档，所有引擎都可以使用
        
#### redo日志
    如果每次更新操作都要随机写盘的话，那么I/O成本就太高了（主要是硬盘的寻道、旋转、数据传输），换成redo日志的方式则是顺序写盘，
    可以节省寻道和旋转的时间，减少随机写盘。等MySQL稍微空闲了再把redo写到各自对应的数据行去。InnoDB中，redo日志的大小是固定的。
    
    redo两阶段提交：prepare和commit，InnoDB先写redo，此时redo的记录为prepare状态，然后MySQL服务层写binlog，然后InnoDB再commit。
    
#### undo日志（回滚段）


(1)常见并发控制保证数据一致性的方法有锁，数据多版本（MVCC）；
(2)普通锁串行，读写锁读读并行，数据多版本读写并行；
(3)redo日志保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；
(4)undo日志用来回滚未提交的事务，它存储在回滚段里；
(5)InnoDB是基于MVCC的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；
(6)InnoDB之所以并发高，快照读不加锁（读回滚段）；
(7)InnoDB所有普通select都是快照读；