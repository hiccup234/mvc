
# 常见面试问题

1、数据库事务特性ACID？

2、数据库事务隔离级别？

3、视图的作用？
    类似Java中HashMap的KeySet,EntrySet,Values等，视图本身不存储数据。
    
4、索引的工作原理及其种类有哪些？

5、数据库范式？
   * 第一范式（1NF） 
        数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。
        如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。
        
        简而言之，第一范式就是列是原子的不可再分割的。

   * 第二范式（2NF）
        第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
        第二范式要求数据库表中的每个实例或行必须可以被惟一地区分，为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。
        这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。
        所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，
        新实体与原实体之间是一对多的关系，为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识（外键）。
        
        简而言之，第二范式就是非主属性完全依赖于主关键字。

   * 第三范式（3NF）
        满足第三范式（3NF）必须先满足第二范式（2NF），第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
        
        例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。
        那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。
        如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。
        
        简而言之，第三范式就是属性不依赖于其它非主属性（消除冗余）。

6、数据库优化思路？
   * 数据库表Schema和数据类型优化
   * 索引优化
   * SQL语句优化 

7、SQL语句连接的种类有哪些?
    1、内连接：join 或 inner join
    2、外连接：左外连接（左表全部，右表没有的补null） 右外连接（右表全部，左表没有的补null）
             全外连接 full join 或 full outer join（左表或右表没有的都补null）
    3、交叉连接：笛卡儿积 cross join (不带条件where)
    

8、drop,delete与truncate的区别
    drop 直接删掉表 
    truncate 删除表中数据，再插入时自增长id又从1开始 
    delete 删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

为什么不建议用UUID作为InnoDB的主键？
1、考虑数据长度，会影响B+Tree的开度，进而影响树的高度，导致I/O次数增加
2、其他普通索引要存储主键，会花费大量空间