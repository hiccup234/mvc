
## MySQL数据库存储引擎：
    非事务性存储引擎：MyISAM、MEMORY、CSV  		采用表级锁定（MySQL临时表的引擎就是MEMORY）
    事务性存储引擎：InnoDB、MariaDB				采用行级锁定
    
### MyISAM与InnoDB的区别：
    1、MyISAM不支持事务，但支持全文检索，InnoDB不支持FULLTEXT类型的索引。
    2、MyISAM引擎的表强调的是性能，其执行数度比InnoDB引擎更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。
    3、InnoDB中不保存表的具体行数，所以执行select count(*) from table时，InnoDB要全表扫描来计算有多少行，
    但是MyISAM只要简单的读出保存好的行数即可。注意：当count(*)语句包含 where条件时，两种表的操作是一样的。
    4、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
    5、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    6、LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，
    导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
    
    InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
    （MyISAM 的表锁是在引擎层实现的）

## MySQL数据库锁分类
    
### 数据库实例全局锁
    flush tables with read lock (FTWRL)，让整个库处于只读状态的，DML和DDL语句都会被阻塞，常用在全库逻辑备份。
   
### 表锁 lock tables … read/write
    优点：加锁开销小，速度快，死锁概率小
    缺点：锁的粒度大，发生锁冲突的概率高，并发度低
 
    注意：表锁直接由MySQL服务器实现，底层存储引擎不用关心，分为：表共享读锁（Table Read Lock）和 表独占写锁（Table Write Lock）
    同级别还有：元数据锁（MDL），也是一把读写分离锁，所有访问表的操作都要加锁，DDL会加写锁，其他则是读锁。
 
### 页锁
    MySQL特有的锁定级别，BerkeleyDB采用了页级锁定，MySQL一个页大小默认为16KB。
 
### 行锁
    优点：锁定粒度最小，发生锁冲突的概率最低，并发度最高
    缺点：加锁开销大，速度慢，出现死锁的概率高
 
    注意：由存储引擎实现，分为：共享锁 和 排他锁，对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加排他锁（X）。
         事务可以通过以下语句显示地给记录集加共享锁或排他锁：
            共享锁（S）：SELECT  FROM table_name WHERE ... LOCK IN SHARE MODE（会造成当前读，即在事务中可以看到其他已提交事务的最新改动，即直接读最新的undolog）
            排他锁（X）：SELECT  FROM table_name WHERE ... FOR UPDATE
    注意：InnoDB的行锁是通过给索引上的索引项加锁来实现的（即，不一定是加在主键上），所以只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。
         InnoDB同时也使用了意向锁（表级锁定），分为意向共享锁和意向排它锁，意向锁是InnoDB自动加的，不需用户干预。
 
### 间隙锁（GAP）
    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁（类比跳表的第0层数据链表的间隙）
    对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”InnoDB也会对这个“间隙”加锁，可以防止幻读，以满足相关隔离级别的要求（RR和串行隔离）。
 
    注意：Read committed 不会加GAP锁，只剩下行锁或表锁了（如果是RC，则需要把binlog设置为row，否则会出现数据和日志的一致性问题）
        Next-Key Lock：假设索引为1,10,20,25,30...每扫描一个索引则会加Next-Key锁，即：扫描1时(0,1] 扫描20时(10,20]，Next-Key = GAP + 行锁。
                     （Next-Key是加锁的基本单位，间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间，
                      实际实现上是：先加(10,20)的间隙锁，然后加20的行锁，来构造Next-key锁）
                     
                      如果是唯一索引的等值查询，Next-Key会退化为行锁，如果是唯一索引的范围查找以及非唯一索引，则不会退化。
 1. 原则 1：加锁的基本单位是 next-key lock（前开后闭区间）。
 2. 原则 2：查找过程中访问到的对象才会加锁（索引覆盖不会引起主键加行锁）。
 3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
 4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，nextkey lock 退化为间隙锁（order by desc是向左遍历，所以B+Tree最低层是双向链表）。
 5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止（唯一索引已经能确定范围的最后一行数据了）。

### 悲观锁与乐观锁
    悲观锁与乐观锁并不是数据库中独有的概念，Java语言中synchronized是悲观锁，自旋的CAS是乐观锁操作。
    MySQL中悲观锁一般是：select ... for update的语句，会对选择的数据加锁，防止其他事务修改数据。
    
    乐观锁则同JUC中AtomicStampedReference类似，也是利用CAS机制，并不会对数据加锁，而是对比每行数据的版本号来判断，防止ABA的问题。

    具体实现：采用数据版本机制，在表中添加一列version，记录数据行每次变更的版本号，更新时校验版本号。
    适用场景：长事务，因为MySQL的锁获取后，数据行更新了不会马上释放，而是等事务提交了才释放，所以长事务的情况下很容易造成死锁。
            高并发，对某行记录会存在同时大量的更新，如银行的顶账户，可以考虑锁分段的思想（桶，LongAdder）

### 两阶段锁协议
    在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。（类比Java中的wait和notify）

#### 死锁
    死锁超时：默认50s
    死锁检测：
    死锁解除：直接kill事务号更大的事务（或是线程？）
