
# 数据库优化

1、首先想到表的Schema与数据类型的设计是否合理，范式化与反范式化的取舍是否合理。

2、检查索引是否合理，表的数据量是否过大，查询是否没有走到索引。

3、查询语句优化，检查执行计划。


## Schema与数据类型优化

1、数据类型尽量采用最小数据类型，用整型代替字符串。
    如：IP地址的存储，用MySQL自建类型代替字符串
    如：date,time,datetime代替字符串存储日期

2、尽量指定列为NOT NULL，因为NULL列会使索引和索引统计等都更复杂。

3、尽量不要使用ENUM和SET，否则后期扩展很麻烦，应把这些限定逻辑放在应用层。


## 索引优化
见下方分析：增加索引、索引覆盖、最左原则、索引前缀（like的前面不能放%）、索引条件下推

## 查询语句优化



# 数据库索引

### 索引分类：
1、哈希索引：O(1) 类似HashMap，速度快，但只适合做等值查询，无法做区间查找（退化为O(n)）
          哈希值是随机离散的，所以每次更新维护索引都会引发磁盘的随机写入

2、有序数组索引：O(log n) 有序数组在等值查询和范围查询场景中的性能就都非常优秀，但是更新时维护索引成本太高

3、搜索树索引：O(log n) 二叉搜索树、B树、B+树
Q: B树与B+树区别？
A: B树：非叶子节点、叶子节点都存储数据，中序遍历可以获得所有数据。
   B+树：非叶子节点不再存储数据，数据只存储在同一层的叶子节点上（B+树中根到每一个节点的路径长度一样，而B树不是这样）
        叶子节点之间增加了链表，获取所有数据不再需要中序遍历（回溯）
其他：跳表、LSM 树

### 一般来说，应该在这些列创建索引：
   * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
   * 在经常需要搜索的列上，可以加快搜索的速度；
   * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
   * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
   * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
   * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
   
### 一般来说，不应该在这些列创建索引：
   * 对于那些在查询中很少使用或者参考的列不应该创建索引。
   * 对于那些只有很少数据值的列也不应该增加索引。
   * 对于那些定义为text,image和bit数据类型的列不应该增加索引
   
### 主键索引 
    数据库表经常有一列或列组合，其值唯一标识表中的每一行，该列称为表的主键。 
    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键中的每个值都唯一。

### 聚集索引
    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
    如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度
    
    类比：普通索引就像书的目录一样，跟书的正文是分开放的，而聚簇索引则类似在书的侧面贴便签贴，索引是直接跟数据行存储在一起的。
    
### 局部性原理与磁盘预读
    由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一。
    因此为了提高效率，要尽量减少磁盘I/O，为了达到这个目的，磁盘I/O往往不是严格按需读取，而是每次都会预读，
    即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
    
    这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。
    
    程序运行期间所需要的数据通常比较集中，由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），
    因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数，页是计算机管理存储器的逻辑块，
    硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4KB），
    主存和磁盘以页为单位交换数据，当程序要读取的数据不在主存中时，会触发一个缺页中断，此时系统会向磁盘发出读盘信号，
    磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中然后返回，程序继续运行。
    
### B-/+Tree索引的性能分析  
    
    一般使用磁盘I/O次数来评价索引结构的优劣。
    
    根据B-Tree的定义，可知检索一次最多需要访问h（树高度）个节点，数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，
    这样每个节点只需要一次I/O就可以完全载入，为了达到这个目的，在实际实现B-Tree时还需要使用如下技巧：
        1、每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
        2、B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。
           一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
        3、而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，
           所以红黑树的I/O渐进复杂度也为O(h)，但效率明显比B-Tree差很多。
    
    
    
    