
# 数据库优化

## Schema与数据类型优化
    首先考虑表的Schema与数据类型的设计是否合理，范式化与反范式化的取舍是否合理：

    0、数据类型尽量采用最小数据类型，尽量用整型代替字符串
        如：IP地址的存储，用INT UNSIGNED存储IPv4，不要用char(15)
        如：date,time,datetime代替字符串存储日期
    1、自增主键ID一般用BIGINT UNSIGNED来存储不可能为负的值 
    2、金融货币可以考虑用BIGINT代替DECIMAL，乘以100倍后货币单位为分
    3、字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高，
      字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间
    4、根据业务区分使用datetime/timestamp，前者占用5个字节，后者占用4个字节，
      存储年使用YEAR，存储日期使用DATE，存储时间使用datetime
    5、必须把字段定义为NOT NULL并设默认值
      （1）NULL的列使用索引，索引统计，值都更加复杂，MySQL优化器更难优化
      （2）NULL需要更多的存储空间
      （3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有坑
    6、使用varchar(20)存储手机号，不要使用整数
      （1）牵扯到国家代号，可能出现+/-/()等字符，例如+86
      （2）手机号不会用来做数学运算
      （3）varchar可以模糊查询，例如like ‘138%’
    7、使用TINYINT来代替ENUM，ENUM增加新值要进行DDL操作，尽量不要使用ENUM和SET，否则后期扩展很麻烦，应把这些限定逻辑放在应用层
    8、UUID应该移除“-”，也可用UNHEX()转换为16字节存储在BINARY(16)中 
    
    NULL: 不会被索引，不参加查询条件计算，需要占用额外的空间。每个row需要额外空间记录哪个col是NULL
          建议尽量避免NULL列，col最好定义成not null，然后设置默认值。
          
    INT/BIGINT: MySQL整型可设置一个“width”属性，这点很容易让人混淆。
                实际上，这不是一个精度，只是告诉客户端工具显示多少个字符而已，如INT(11):11表示的不是数值范围，而只是显示的宽度。

## 索引优化
    检查索引是否合理，表的数据量是否过大，查询是否没有走到索引。

    见下方分析：增加索引、索引覆盖、最左原则、索引前缀（like的前面不能放%）、索引条件下推
    
    1、如果索引列是表达式的一部分则无法走到该索引（索引参与计算，如果索引在单独的一边则不影响）（可能优化器会选择该索引，但已经不是拿来做查找了）
    2、索引选择性越高查询效率越好，唯一索引的选择性最高，性能也最好
    3、合理使用联合索引，将选择性高的列放在最左边
    4、避免隐式类型转换（字符串与数字比较，MySQL默认是转成数字比较），还要注意字符串编码的转换（如果两张表字符串编码不一致，关联查询时仍不会走索引）

## 查询优化
    查询语句优化，检查执行计划：


# 数据库索引（索引跟数据文件一样，也是放在磁盘的文件中）

### 索引分类：
1、哈希索引：O(1) 类似HashMap，速度快，但只适合做等值查询，无法做区间查找（退化为O(n)）
          哈希值是随机离散的，所以每次更新维护索引都会引发磁盘的随机写入

2、有序数组索引：O(log n) 有序数组在等值查询和范围查询场景中的性能就都非常优秀，但是更新时维护索引成本太高

3、搜索树索引：O(log n) 二叉搜索树、B树、B+树（类比跳表）
Q: B树与B+树区别？
A: B树：非叶子节点、叶子节点都存储数据，中序遍历可以获得所有数据。
   B+树：非叶子节点不再存储数据，数据只存储在同一层的叶子节点上（B+树中根到每一个节点的路径长度一样，而B树不是这样）
        叶子节点之间增加了链表，获取所有数据不再需要中序遍历（回溯）
其他：跳表、LSM树

自定义哈希索引：在表中对应数据列的地方再新建一个数据列，用来存对应列的hash值，新建列通过B+Tree索引

### 一般来说，应该在这些列创建索引：
   * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
   * 在经常需要搜索的列上，可以加快搜索的速度；
   * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
   * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
   * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
   * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
   
### 一般来说，不应该在这些列创建索引：
   * 对于那些在查询中很少使用或者参考的列不应该创建索引。
   * 对于那些只有很少数据值的列也不应该增加索引。
   * 对于那些定义为text,image和bit数据类型的列不应该增加索引
   
### 主键索引 
    数据库表经常有一列或列组合，其值唯一标识表中的每一行，该列称为表的主键。 
    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键中的每个值都唯一。

### 聚集索引
    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
    如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度
    
    类比：普通索引就像书的目录一样，跟书的正文是分开放的，而聚簇索引则类似在书的侧面贴便签贴，索引是直接跟数据行存储在一起的。
    
### 唯一索引与普通索引
    唯一索引：插入时需要判断是否存在冲突，所以涉及到磁盘I/O的随机访问
    普通索引：更新直接写入change buffer，性能更高
    
    在查询性能上，这两种索引没有明显的差别，但是更新时普通索引性能更好，所以尽量用普通索引。
    写后马上读的情况关闭change buffer，来避免马上读带来的merge操作（也是随机I/O），写多读少则调大change buffer来提升写性能。
    
    （redo log主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗）
    
### 局部性原理与磁盘预读
    由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一。
    因此为了提高效率，要尽量减少磁盘I/O，为了达到这个目的，磁盘I/O往往不是严格按需读取，而是每次都会预读，
    即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
    
    这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。
    
    程序运行期间所需要的数据通常比较集中，由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），
    因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数，页是计算机管理存储器的逻辑块，
    硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4KB），
    主存和磁盘以页为单位交换数据，当程序要读取的数据不在主存中时，会触发一个缺页中断，此时系统会向磁盘发出读盘信号，
    磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中然后返回，程序继续运行。
    
### B-/+Tree索引的性能分析  
    
    一般使用磁盘I/O次数来评价索引结构的优劣。
    
    根据B-Tree的定义，可知检索一次最多需要访问h（树高度）个节点，数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，
    这样每个节点只需要一次I/O就可以完全载入，为了达到这个目的，在实际实现B-Tree时还需要使用如下技巧：
        1、每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
        2、B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。
           一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
        3、而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，
           所以红黑树的I/O渐进复杂度也为O(h)，但效率明显比B-Tree差很多。
    
    
    
    