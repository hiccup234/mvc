
# MySQL数据库锁分类：
 
    非事务性存储引擎：MyISAM、MEMORY、CSV  		采用表级锁定
    
    事务性存储引擎：InnoDB 						采用行级锁定
## 数据库实例全局锁
   flush tables with read lock (FTWRL)，让整个库处于只读状态的，DML和DDL语句都会被阻塞，常用在全库逻辑备份。
   
## 表级锁定（同级别还有：元数据锁）  lock tables … read/write
  * 加锁开销小，速度快
  * 不会出现死锁
  * 锁的粒度大，发生锁冲突的概率最高
  * 并发度最低
 
    注意：直接由MySQL服务器实现，底层存储引擎不用关心，分为： 表共享读锁（Table Read Lock） 和 表独占写锁（Table Write Lock）
    
    元数据锁：MDL，是一把读写分离的锁，所有访问表的操作都要加锁，DDL会加写锁，其他则是读锁。
 
## 页级锁定
  MySQL特有的锁定级别，BerkeleyDB采用了页级锁定
 
## 行级锁定
  * 加锁开销大，速度慢
  * 会出现死锁的情况
  * 锁定粒度最小，发生锁冲突的概率最低
  * 并发度最高
 
    注意：由存储引擎实现，分为：共享锁 和 排他锁，InnoDB同时也使用了意向锁（表级锁定），分为意向共享锁和意向排它锁。
         意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。
 
    事务可以通过以下语句显示地给记录集加共享锁或排他锁：
        共享锁（S）：SELECT  FROM table_name WHERE ... LOCK IN SHARE MODE
        排他锁（X）：SELECT  FROM table_name WHERE ... FOR UPDATE
 
    注意：InnoDB的行锁是通过给索引上的索引项加锁来实现的，所以只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。
 
## 间隙锁（GAP）
  当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；
  对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”InnoDB也会对这个“间隙”加锁，可以防止幻读，以满足相关隔离级别的要求。
 
  注意：Read committed 不会加GAP锁
       Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。
 
  通过索引实现锁定：
    （1）当Query无法利用索引的时候，InnoDB会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低。
    （2）当Query使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所对应的数据可能有部分并不属于该Query的结果集，
        但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；
 
 
## 悲观锁与乐观锁
    悲观锁与乐观锁并不是数据库中独有的概念，Java语言中synchronized是悲观锁，自旋的CAS是乐观锁操作。
    MySQL中悲观锁一般是：select ... for update的语句，会对选择的数据加锁，防止其他事务修改数据。
    乐观锁则同JUC中AtomicFieldUpdater类似，也是利用CAS机制，并不会对数据加锁，而是对比每行数据的系统版本号来判断。


## MyISAM与InnoDB的区别：
    1、MyISAM不支持事务，但支持全文检索，InnoDB不支持FULLTEXT类型的索引。

    2、MyISAM引擎的表强调的是性能，其执行数度比InnoDB引擎更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。

    3、InnoDB中不保存表的具体行数，所以执行select count(*) from table时，InnoDB要全表扫描来计算有多少行，
    但是MyISAM只要简单的读出保存好的行数即可。注意：当count(*)语句包含 where条件时，两种表的操作是一样的。

    4、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。

    5、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。

    6、LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，
    导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
    
    InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
    

### redo日志
    如果每次更新操作都要随机写盘的话，那么I/O成本就太高了（主要是硬盘的寻道、旋转、数据传输），换成redo日志的方式则是顺序写盘，
    可以节省寻道和旋转的时间，减少随机写盘。等MySQL稍微空闲了再把redo写到各自对应的数据行去。InnoDB中，redo日志的大小是固定的。
    
    redo两阶段提交：prepare和commit，InnoDB先写redo，此时redo的记录为prepare状态，然后MySQL服务层写binlog，然后InnoDB再commit。
    
### undo日志（回滚段）

### binlog
    MySQL服务层实现的，主要用来归档，所有引擎都可以使用


(1)常见并发控制保证数据一致性的方法有锁，数据多版本（MVCC）；
(2)普通锁串行，读写锁读读并行，数据多版本读写并行；
(3)redo日志保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；
(4)undo日志用来回滚未提交的事务，它存储在回滚段里；
(5)InnoDB是基于MVCC的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；
(6)InnoDB之所以并发高，快照读不加锁（读回滚段）；
(7)InnoDB所有普通select都是快照读；