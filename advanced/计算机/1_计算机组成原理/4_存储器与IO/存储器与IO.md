

### SRAM 与 DRAM

    SRAM：静态存储器，一个bit数据需要6~8个晶体管来存储，电路简单访问快速，但存储密度不高，常用来做CPU的高速缓存（L1/L2/L3）。
    
    DRAM：动态存储器，由一个晶体管+一个电容来存储一个bit，但是电容会不断漏电，所以要求定时刷新充电才能保持数据不丢失，常用来做内存。
    
### SSD 与 HDD

    Solid-state disk
    
    Hard Disk Drive
    
    SSD：SLC(Single-Level Cell)、MLC、TLC、QLC    PE擦写    闪存转换层（FTL）    预留空间7-15%    写入放大   
    基于SSD的k-v数据库：AeroSpike
                 

### 局部性原理与缓存
```
int[] arr = new int[64 * 1024 * 1024];
// 循环 1
for (int i = 0; i < arr.length; i++) arr[i] *= 3;
// 循环 2（Cache Line的大小一般为64Byte，所以这里步长为16）
for (int i = 0; i < arr.length; i += 16) arr[i] *= 3
```
如上程序，循环1与循环2的执行时间相差不大。
    
CPU与高速缓存L1/L2/L3的映射关系：
    1、直接映射，通常采用mod运算（实际是h&(n-1)，类似HashMap），缓存行中用组标记（Tag）存储取模截取后留下的高位，来解决取模冲突的问题。
    2、全相连映射
    3、组相连映射
高速缓存写策略：
    1、写直达（Write-Through），即就算Cache Block里有数据，也每次都要写入主内存（类似volatile的效果）
    2、写回（Write-Back），即判断是否Cache Block有数据且原数据是否为脏数据，如果是把源数据写回内存，并把当前数据写入Cache Block，并标记为脏数据
    
缓存一致性原理：
    1、写传播，CPU1写L1后需要传播到CPU2的L1
    2、事务串行化，同时有两个核心写L1，写的值不同，最后传播到其他核心的顺序就可能不同，所以要“加锁”来串行化
    
    总线嗅探机制 和 MESI协议
    1、总线嗅探就是把所有的读写请求都通过总线Bus广播给所有CPU核心，让每个核心嗅探这些请求并做出处理
    2、MESI写失效协议，只有一个CPU核心写数据，写入之后广播“失效”请求告诉其他CPU核心，
        还有一种写广播，即将写请求广播到所有CPU核心，同时更新所有核心里的Cache Block。写广播需要广播写的数据，所以更占带宽。
        M：代表已修改（Modified），Cache Block中数据已修改还未写回内存
        E：代表独占（Exclusive），表示该数据只有当前CPU核心加载到了缓存里，其他CPU核心都未加载，
                               此时如果从总线收到对应数据的读请求，则证明其他CPU核心也从内存加载了，所以要改成共享状态
        S：代表共享（Shared），此时如果要更新缓存数据，则需要先广播其他核心将对应数据变成失效状态之后才能写当前缓存
        I：代表已失效（Invalidated），Cache Block中数据已不可用，需要重新从主内存加载
        