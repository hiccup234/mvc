
## 可执行文件格式
    Linux -->  ELF: Execuatable and Linkable File Format
    Windows -->  PE: Portable Executable Format
    Max --> Mach-O
    
### 静态链接
    ELF文件有三类:可重定向文件、可执行文件、共享目标文件。
    代码经过预处理、编译、汇编后形成可重定向文件，可重定向文件经过链接（静态链接）后生成可执行文件（合并代码段）。
    1、符号表 2、重定向表
### 动态链接
    动态链接是针对程序的共享代码库，如C的标准代码库，Windows下为`.dll`文件 -- Dynamic-Link Libary，而Linux下为`.so`文件 -- Shared Object
    共享代码库中的代码要求是地址无关的
    1、PLT 程序链接表（Procedure Link Table） 2、GOT 全局偏移表（GOT，Global Offset Table）（进程私有的）
                                            
## 程序装载
    1、可执行文件加载后占用的内存空间应该是连续的（因为PC寄存器是自增1的）
    2、计算机会同时加载运行很多个程序，并且不能让程序自己规定在内存中加载的位置（由操作系统统一分配和管理，不然会造成冲突）
    
    虚拟内存地址：机器码指令里用到的地址
    物理内存地址：内存硬件里面的地址空间（虚拟内存和物理内存通过页表机制进行映射和转换）
    
   * 内存分段：每个程序单独占据一段连续的内存空间（内存碎片严重），操作系统只负责维护物理内存的起始地址和空间大小即可，而应用程序只关心自己的地址空间
              碎片严重的情况下，无法为新程序分配足够内存，则进行内存交换（SWAP），把某些程序换到硬盘。

   * 内存分页：首先把物理内存分为固定大小的页（Linux默认的页大小为4KB，getconf PAGE_SIZE），应用程序的地址空间也要分成同样大小的页，
              然后，把物理内存的页同应用程序的页映射起来，就可以做到应用程序内存地址空间连续。
              同时，应用程序地址空间分页后，就可以做到启动时只加载部分页到物理内存（即建立映射），直到需要读取其他页时，由CPU触发缺页中断，
              再由操作系统加载对应的页到物理内存中来。
              
   